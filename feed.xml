<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://wjohn1483.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://wjohn1483.github.io/" rel="alternate" type="text/html" /><updated>2025-10-06T08:45:30+00:00</updated><id>https://wjohn1483.github.io/feed.xml</id><title type="html">wjohn1483.github.io</title><subtitle></subtitle><author><name>Your Name</name></author><entry><title type="html">Neural News Recommendation with Multi-Head Self-Attention</title><link href="https://wjohn1483.github.io/2025/10/06/nrms/" rel="alternate" type="text/html" title="Neural News Recommendation with Multi-Head Self-Attention" /><published>2025-10-06T00:00:00+00:00</published><updated>2025-10-06T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2025/10/06/nrms</id><content type="html" xml:base="https://wjohn1483.github.io/2025/10/06/nrms/"><![CDATA[<p>最近剛好又回頭碰了一下推薦系統，這邊記錄一下看了NRMS這篇paper的筆記。</p>

<!--more-->

<h2 id="簡介">簡介</h2>

<p><a href="https://wuch15.github.io/paper/EMNLP2019-NRMS.pdf">這篇paper</a>是刊登在EMNLP 2019上面的，做新聞推薦的paper。</p>

<p>作者認為，要了解新聞本身，新聞標題裡面字跟字的關聯是很重要的，所以採用self-attention的方式來去得到新聞的embedding，而使用者看過的新聞展示出了使用者的喜好，中間也適合使用attention來找到使用者真正在意的主題是什麼。</p>

<p><img src="user_history.png" alt="User history" /></p>

<p>以上圖為例子，Rockets trade Carter Williams to the Bulls中的Rockets、trade、Bulls就是重要的關鍵字；而使用者看過的文章裡面，可以明顯看出使用者是比較在意NBA相關的新聞，雖然中間穿插了些天氣預報等，但使用者喜歡的東西還是有一個主題在。</p>

<h2 id="模型架構">模型架構</h2>

<p><img src="nrms.png" alt="NRMS" /></p>

<p>上圖是NRMS這篇paper的模型架構，主要分成兩個部分：News Encoder和User Encoder。</p>

<h3 id="news-encoder">News Encoder</h3>

<p>News encoder的架構在整體架構圖的左手邊，主要就是一個self-attention layer。</p>

<p>新聞的標題會先被斷詞以後，透過預先訓練好的word embedding像是Glove轉換成$\textbf{e}_1, \textbf{e}_2, …, \textbf{e}_M$，接著通過self-attention layer以後最終得到新聞的embedding $\textbf{r}$，細節的計算方法如下</p>

\[\alpha^k_{i,j}=\frac{\exp\left( \textbf{e}_i^T\textbf{Q}^w_k\textbf{e}_j \right)}{\sum^m_{m=1}\exp\left( \textbf{e}^T_i\textbf{Q}^w_k\textbf{e}_m \right)}\]

\[\textbf{h}^w_{i,k}=\textbf{V}^w_k\left( \sum\limits^M\limits_{j=1}\alpha^k_{i,j}\textbf{e}j \right)\]

<p>這邊計算的是某一個multi-head當中的$head_k$對於某一個字 $word_i$，其對同一篇新聞的其他字的self-attention，透過$\textbf{Q}^w_k$計算出其他字的attention weight $\alpha^k_{i,j}$，然後透過一個projection parameters$\textbf{V}^w_k$得到這個字的hidden state $\textbf{h}^w_{i,k}$，最後把所有head的結果接在一起變成了$\textbf{h}^w_i$</p>

\[\textbf{h}^w_i=\left[ \textbf{h}^w_{i,1};\textbf{h}^w_{i,2};...;\textbf{h}^w_{i,h} \right]\]

<p>把每個字$w_i$轉成word embedding $\textbf{e}_i$，再經過self-attention得到$\textbf{h}^w_i$以後，最終再經過一個attention layer來得到最後的新聞embedding $\textbf{r}$</p>

\[a^w_i=\textbf{q}^T_w\tanh\left( \textbf{V}_w\times\textbf{h}^w_i+\textbf{v}_w \right)\]

\[\alpha^w_i=\frac{\exp (a^w_i)}{\sum^m_{j=1}\exp(a^w_j)}\]

\[\textbf{r}=\sum\limits^{M}\limits_{i=1}\alpha^w_i\textbf{h}^w_i\]

<p>這邊使用一個fully connected的layer去算出attention weight，然後把先前算出來的$\textbf{h}^w_i$再weighted sum起來，從paper上面看起來，這邊的$\textbf{q}^T_w$好像就是讓模型自己訓練出來的參數。</p>

<h3 id="user-encoder">User Encoder</h3>

<p>User encoder的架構跟上面的news encoder一模一樣，只是這邊輸入的部分從一個新聞標題變成了使用者瀏覽過的新聞的embedding $\textbf{r}_i$，計算的方法如同上面news encoder的算法，最終會得到一個使用者embedding $\textbf{u}$。</p>

<p>在有了使用者embedding $\textbf{u}$以後，我們可以把想要推薦給使用者的候選新聞，通過news encoder得到$\textbf{r}^c$，直接透過dot product來決定這則候選新聞的分數，最後照著分數排序把結果推薦給使用者。</p>

\[\hat{y}=\textbf{u}^T\textbf{r}^c\]

<h3 id="training">Training</h3>

<p>訓練的方式跟siamese network的訓練方式相近，從所有的資料裡面去抽樣出$K$筆negative data出來，希望模型給positive data的分數要大過給negative data的分數。</p>

\[p_i=\frac{\exp(\hat{y}^+_i)}{\exp(\hat{y}^+_i)+\sum^K_{j=1}\exp(\hat{y}^-_{i,j})}\]

\[\mathcal{L}=-\sum\limits_{i\in S}\log(p_i)\]

<h2 id="實驗結果">實驗結果</h2>

<p>從結果當中可以看到，NRMS在各個經典的模型裡面表現不俗。</p>

<p><img src="results.png" alt="Results" /></p>

<h2 id="結論">結論</h2>

<p>NRMS是一個架構沒有很複雜，但效果還不錯的一個模型，在<a href="https://github.com/recommenders-team/recommenders">recommenders</a>裡面也有支援，如果有需要推薦新聞的場景可以試試看。</p>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li><a href="https://haren.medium.com/notes-nrms-neural-news-recommendation-with-multi-head-self-attention-99ad5e9bd320">[Notes](EMNLP2019) NRMS: Neural News Recommendation with Multi-Head Self-Attention</a></li>
</ul>]]></content><author><name>Your Name</name></author><category term="Recommendation-System" /><category term="Paper" /><summary type="html"><![CDATA[最近剛好又回頭碰了一下推薦系統，這邊記錄一下看了NRMS這篇paper的筆記。]]></summary></entry><entry><title type="html">ROC和PR曲線</title><link href="https://wjohn1483.github.io/2025/09/29/roc-and-pr/" rel="alternate" type="text/html" title="ROC和PR曲線" /><published>2025-09-29T00:00:00+00:00</published><updated>2025-09-29T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2025/09/29/roc-and-pr</id><content type="html" xml:base="https://wjohn1483.github.io/2025/09/29/roc-and-pr/"><![CDATA[<p>最近剛好碰到了個binary classification的問題，來順便複習一下ROC和PR曲線。</p>

<!--more-->

<h2 id="4種可能的結果">4種可能的結果</h2>

<p>為了要訓練一個binary classification的模型，我們通常會先去蒐集有被標註的資料集，而資料集裡面會包含每一筆資料的特徵以及它是positive還是negative的label。用這個資料集訓練好一個binary classification的模型以後，我們可以將這個模型拿去預測資料集裡面testing set的資料，並設定一個門檻，高於門檻的認定為positive data，低於的認定為negative，比較模型預測的結果和實際資料的標註，我們可以得到下面的confusion matrix。</p>

<table>
  <thead>
    <tr>
      <th><strong>模型預測</strong></th>
      <th><strong>實際資料</strong></th>
      <th><strong>狀況名稱</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Positive</td>
      <td>Positive</td>
      <td>True Positive</td>
    </tr>
    <tr>
      <td>Positive</td>
      <td>Negative</td>
      <td>False Positive</td>
    </tr>
    <tr>
      <td>Negative</td>
      <td>Positive</td>
      <td>False Negative</td>
    </tr>
    <tr>
      <td>Negative</td>
      <td>Negative</td>
      <td>True Negative</td>
    </tr>
  </tbody>
</table>

<h2 id="receiver-operating-characteristicroc">Receiver Operating Characteristic（ROC）</h2>

<p>ROC曲線就是根據上面的confusion matrix展開，ROC曲線將False positive rate當作是橫軸，True positive rate當作是縱軸，每一個點設定不同的門檻值以此來畫出來的曲線，而兩者的定義分別是</p>

\[False\ positive\ rate=\frac{False\ positive}{False\ positive + True\ negative}\]

\[True\ positive\ rate=\frac{True\ positive}{True\ positive+False\ negative}\]

<p>可以把False positive rate想成是所有實際資料被標註成negative的情況中，有多少比例模型判斷為是positive，越高表示模型越<strong>不會</strong>判斷negative data；而True positive rate可以想成是所有實際資料被標註成positive的情況中，有多少比例模型判斷為是positive，越高表示模型越會判斷positive data。</p>

<p>下圖是一個ROC曲線的範例，使用的資料和模型的預測都是隨機產生的</p>

<p><img src="./roc_curve.png" alt="ROC Curve" /></p>

<p>在這張圖片裡面有3個點比較重要</p>

<ul>
  <li>
    <p>(0, 1)：這個點表示True positive rate是1，且false positive rate是0，代表模型達到了完美的狀態，可以完全分辨出positive data和negative data</p>
  </li>
  <li>
    <p>(0, 0)：這個點表示兩個rate都是0，也就是把模型的threshold設定成1，把所有的資料都判定成negative data</p>
  </li>
  <li>
    <p>(1, 1)：這個點表示兩個rate都是1，也就是把模型的threshold設定成0，把所有的資料都判定成positive data</p>
  </li>
</ul>

<p>而在這個曲線下面的面積Area Under Curve（AUC）表示了這個模型整體的表現如何，面積越大通常表示這個模型越能分辨出positive data和negative data，而在45度的斜線是隨機猜positive或negative可以獲得的結果。</p>

<h2 id="precision-recall">Precision Recall</h2>

<p>PR曲線是以Recall為X軸、Precision為Y軸，每個點設定不同的門檻值畫出來的曲線，兩者的定義分別是</p>

\[Precision=\frac{True\ positive}{True\ positive+False\ positive}\]

\[Recall=\frac{True\ positive}{True\ positive+False\ negative}\]

<p>Precision表示的是，模型認為是positive data的條件下，真的是positive data的比例有多少；Recall表示的是，所有positive data裡面，有多少是有被模型正確分辨出來的，跟True positive rate的定義一樣。</p>

<p><img src="./pr_curve.png" alt="PR Curve" /></p>

<p>在PR曲線裡面我們也可以計算AUC，這邊的AUC被稱作是Average Precision（AP），而(1, 1)表示最理想的情況，模型可以完美地分辨positive data和negative data，因此PR曲線越往右上角代表模型整體表現更好，越平表示越差。</p>

<h2 id="f1-score">F1 Score</h2>

<p>F1 score的定義是</p>

\[F1=\frac{2*Precision*Recall}{Precision+Recall}\]

<p>表示的是在PR曲線上的一個點，亦即是在固定一個門檻值的時候，模型的表現如何，相較於上面AUC和AP，他們表示的是不論門檻值，模型整體的表現。</p>

<h2 id="兩個曲線的比較">兩個曲線的比較</h2>

<table>
  <thead>
    <tr>
      <th><strong>比較項目</strong></th>
      <th><strong>ROC 曲線</strong></th>
      <th><strong>PR 曲線</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>側重點</td>
      <td>整體分類能力</td>
      <td>正例（Positive Class）的分類能力</td>
    </tr>
    <tr>
      <td>適用場景</td>
      <td>當正負樣本數量相近時效果較好，如果負樣本很多，ROC曲線會看起來比較樂觀</td>
      <td>當正負樣本數極度不平衡時更適用</td>
    </tr>
    <tr>
      <td>X 軸變數</td>
      <td>假正例率（FPR）</td>
      <td>召回率（Recall）</td>
    </tr>
    <tr>
      <td>Y 軸變數</td>
      <td>真正例率（TPR）</td>
      <td>精確率（Precision）</td>
    </tr>
    <tr>
      <td>曲線形狀影響因素</td>
      <td>負例（Negative Class）的影響較大</td>
      <td>主要關注正例（Positive Class）的表現</td>
    </tr>
  </tbody>
</table>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li><a href="https://tsupei.github.io/nlp/2019/12/30/prcurve.html">Chen Tse-Pei’s Blog</a></li>
</ul>]]></content><author><name>Your Name</name></author><category term="Machine-Learning" /><summary type="html"><![CDATA[最近剛好碰到了個binary classification的問題，來順便複習一下ROC和PR曲線。]]></summary></entry><entry><title type="html">Model Context Protocol簡單實作</title><link href="https://wjohn1483.github.io/2025/04/03/mcp-introduction/" rel="alternate" type="text/html" title="Model Context Protocol簡單實作" /><published>2025-04-03T00:00:00+00:00</published><updated>2025-04-03T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2025/04/03/mcp-introduction</id><content type="html" xml:base="https://wjohn1483.github.io/2025/04/03/mcp-introduction/"><![CDATA[<p>最近Model Context Protocol（MCP）蔚為風潮，這篇文章嘗試簡單介紹一下並使用一個範例來實作看看。</p>

<!--more-->

<h2 id="model-context-protocol">Model Context Protocol</h2>

<p>Model Context Protocol（MCP）是一個由Claude背後的公司<a href="https://www.anthropic.com/news/model-context-protocol">Anthropic提出來的概念</a>，我們知道現在要讓LLM產生一個json response已經是一件可行的事情了，而MCP想要做到的事情是讓LLM在產生答案的時候自行決定要不要調用外部的function來取得資料，有點類似Retrieval Augmented Generation（RAG）的概念，只是在RAG的時候，我們需要先把資料放進到資料庫裡面，LLM才可以取得相對應的資料出來，而MCP可以取得更即時的資料。</p>

<p>舉例來說，假設我想要知道台北現在的天氣並詢問LLM，LLM可以透過MCP的server去打API獲得天氣的資訊回來以後再產生回覆給我，如果是RAG的方式，使用者必須先把今天天氣的資訊輸入到資料庫裡面以後，LLM才有機會可以回答出即時的資訊。</p>

<p><img src="./mcp_architecture.png" alt="MCP Architecture" /></p>

<p><em><a href="https://modelcontextprotocol.io/introduction">Introduction - Model Context Protocol</a></em></p>

<p>上圖是一個MCP運作的示意圖，左邊的Host可以想成是LLM的操控介面，可以透過Claude的app或者是其他IDE甚至是自己寫的UI來操作LLM，而這個Host會根據需求去與本機上面的其他MCP server溝通，可能是去得到本機上某一個路徑底下的檔案有哪些、可能是去讀取機器上的某一個檔案或者是去打API拿到相關的資料回來，最後Host會將從MCP server取得的資訊彙整起來再產生回覆給使用者。</p>

<h2 id="創建mcp-server">創建MCP Server</h2>

<p>底下來演示一下一個簡單的MCP server要如何創建，假設我們想要創建一個server，讓LLM可以知道機器上某一個路徑底下的檔案有哪些，我們可以這樣實作。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># mcp_file_server.py
</span><span class="kn">import</span> <span class="n">os</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">from</span> <span class="n">mcp.server.fastmcp</span> <span class="kn">import</span> <span class="n">FastMCP</span>


<span class="n">mcp</span> <span class="o">=</span> <span class="nc">FastMCP</span><span class="p">(</span><span class="sh">"</span><span class="s">File</span><span class="sh">"</span><span class="p">)</span>

<span class="nd">@mcp.tool</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">list_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">Lists all files in the given directory.</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">mcp</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">transport</span><span class="o">=</span><span class="sh">"</span><span class="s">stdio</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>我們可以先透過<code class="language-plaintext highlighter-rouge">pip3 install mcp</code>把相關的dependency安裝起來，接著定義一個function <code class="language-plaintext highlighter-rouge">list_path</code>並用decorator <code class="language-plaintext highlighter-rouge">@mcp.tool()</code>包起來，讓LLM知道底下的function是一個tool，建議這邊把function的註解寫得詳盡一點，這樣LLM會比較清楚這個工具的功能是什麼。</p>

<p>在做好工具以後，我們可以透過底下的指令來測試一下我們做出來的工具</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcp dev PATH_TO_YOUR_TOOL.py
<span class="c"># e.g. mcp dev mcp_file_server.py</span>
</code></pre></div></div>

<p>這時透過瀏覽器連上畫面跑出來的網址，我們可以看到一個UI介面</p>

<p><img src="./mcp_dev_start.png" alt="MCP dev start" /></p>

<p>這時候調整一下左邊的command和argument，分別換成<code class="language-plaintext highlighter-rouge">python</code>和你檔案的名稱像是<code class="language-plaintext highlighter-rouge">mcp_file_server.py</code>，按下Connect以後應該就能順利地連上MCP server了，接著點選上方的Tools、再點選List Tools就可以看到我們自定義的function <code class="language-plaintext highlighter-rouge">list_path</code>。</p>

<p><img src="./mcp_dev_test.png" alt="MCP dev test" /></p>

<p>我們點選<code class="language-plaintext highlighter-rouge">list_path</code>後可以在右邊看到我們寫的註解和需要輸入的參數，這邊可以自己給一些參數進去看看function執行的結果有沒有符合預期。</p>

<h2 id="與llm-agent融合">與LLM Agent融合</h2>

<p>前面我們製作了一個MCP server可以幫忙列出機器上某一個路徑底下的檔案，接下來我們想要讓LLM知道有這個工具並讓它來使用，這邊我們可以透過OpenAI的模型和<a href="https://www.langchain.com/">LangChain</a>來實現。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>gradio langchain langchain-mcp-adapters langchain-openai langgraph
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># llm_server.py
</span><span class="kn">from</span> <span class="n">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
<span class="kn">import</span> <span class="n">gradio</span> <span class="k">as</span> <span class="n">gr</span>
<span class="kn">from</span> <span class="n">langchain_mcp_adapters.tools</span> <span class="kn">import</span> <span class="n">load_mcp_tools</span>
<span class="kn">from</span> <span class="n">langchain_openai</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span> <span class="n">langgraph.prebuilt</span> <span class="kn">import</span> <span class="n">create_react_agent</span>
<span class="kn">from</span> <span class="n">mcp</span> <span class="kn">import</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="n">StdioServerParameters</span>
<span class="kn">from</span> <span class="n">mcp.client.stdio</span> <span class="kn">import</span> <span class="n">stdio_client</span>

<span class="nf">load_dotenv</span><span class="p">()</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">ChatOpenAI</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="sh">"</span><span class="s">gpt-4o-mini</span><span class="sh">"</span><span class="p">)</span>

<span class="n">server_params</span> <span class="o">=</span> <span class="nc">StdioServerParameters</span><span class="p">(</span>
    <span class="n">command</span><span class="o">=</span><span class="sh">"</span><span class="s">python</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">mcp_file_server.py</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">get_prompt</span><span class="p">(</span><span class="n">user_input</span><span class="p">,</span> <span class="n">history</span><span class="p">):</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chat</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>
        <span class="n">role</span> <span class="o">=</span> <span class="n">chat</span><span class="p">[</span><span class="sh">"</span><span class="s">role</span><span class="sh">"</span><span class="p">]</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">chat</span><span class="p">[</span><span class="sh">"</span><span class="s">content</span><span class="sh">"</span><span class="p">]</span>
        <span class="n">messages</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">"</span><span class="s">role</span><span class="sh">"</span><span class="p">:</span> <span class="n">role</span><span class="p">,</span> <span class="sh">"</span><span class="s">content</span><span class="sh">"</span><span class="p">:</span> <span class="n">content</span><span class="p">})</span>
    <span class="n">messages</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span><span class="sh">"</span><span class="s">role</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">user</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">content</span><span class="sh">"</span><span class="p">:</span> <span class="n">user_input</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">messages</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">run_agent</span><span class="p">(</span><span class="n">user_input</span><span class="p">,</span> <span class="n">history</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="nf">stdio_client</span><span class="p">(</span><span class="n">server_params</span><span class="p">)</span> <span class="nf">as </span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">write</span><span class="p">):</span>
        <span class="k">async</span> <span class="k">with</span> <span class="nc">ClientSession</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">write</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">session</span><span class="p">.</span><span class="nf">initialize</span><span class="p">()</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">load_mcp_tools</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

            <span class="n">agent</span> <span class="o">=</span> <span class="nf">create_react_agent</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">tools</span><span class="p">)</span>
            <span class="n">messages</span> <span class="o">=</span> <span class="nf">get_prompt</span><span class="p">(</span><span class="n">user_input</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span>
            <span class="n">agent_response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">agent</span><span class="p">.</span><span class="nf">ainvoke</span><span class="p">({</span><span class="sh">"</span><span class="s">messages</span><span class="sh">"</span><span class="p">:</span> <span class="n">messages</span><span class="p">})</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">messages</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">agent_response</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">agent_response</span><span class="p">[</span><span class="sh">"</span><span class="s">messages</span><span class="sh">"</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">content</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Blocks</span><span class="p">(</span><span class="n">fill_height</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fill_width</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">demo</span><span class="p">:</span>
        <span class="n">gr</span><span class="p">.</span><span class="nc">ChatInterface</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">run_agent</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="sh">"</span><span class="s">messages</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">demo</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre></div></div>

<p>這邊我們把OpenAI的key放進<code class="language-plaintext highlighter-rouge">.env</code>的檔案裡面，並在上面的script透過<code class="language-plaintext highlighter-rouge">load_dotenv()</code>放到環境變數裡面</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .env</span>
<span class="nv">OPENAI_API_KEY</span><span class="o">=</span><span class="s2">"YOUR_KEY_HERE"</span>
</code></pre></div></div>

<p>接下來定義<code class="language-plaintext highlighter-rouge">server_params</code>來設定一下我們的MCP server該怎麼被執行，而<code class="language-plaintext highlighter-rouge">get_prompt()</code>這個function會把使用者和LLM過去的對話紀錄整理起來變成下一次要輸入的prompt，最後透過<code class="language-plaintext highlighter-rouge">run_agent()</code>來串起MCP server和LLM，並使用<a href="https://wjohn1483.github.io/2025/02/22/gradio-introduction/">Gradio的UI</a>來讓使用者來操作。</p>

<p>透過<code class="language-plaintext highlighter-rouge">python3 llm_server.py</code>把Gradio的server起起來後，下一個列出文件的prompt就可以成功呼叫到上面創建的MCP server，並回傳機器上面的檔案名稱了。</p>

<p><img src="./llm_server.png" alt="LLM Server" /></p>

<p>如果覺得需要自己弄一個Gradio UI來使用MCP server太麻煩，可以參考<a href="https://www.linkedin.com/pulse/how-use-mcp-server-tools-claude-app-mariusz-misiek-aszxe/">網路上的教學</a>來使用Claude app或是<a href="https://www.youtube.com/watch?v=McNRkd5CxFY">透過Cursor</a>來操作。</p>

<h2 id="結論">結論</h2>

<p>這篇文章實作了一個簡單的MCP server，賦予LLM能力來根據需求自行調用來得知機器上某個路徑底下的檔案有哪些，以這個為基礎，我們可以擴充MCP server的function，讓LLM可以使用更多的工具來減少人類需要自行調用資料再放進prompt裡面的負擔。</p>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li><a href="https://modelcontextprotocol.io/introduction">Introduction - Model Context Protocol</a></li>
  <li><a href="https://www.linkedin.com/pulse/how-use-mcp-server-tools-claude-app-mariusz-misiek-aszxe/">How to use MCP server tools in the Claude App?</a></li>
  <li><a href="https://www.youtube.com/watch?v=McNRkd5CxFY">MCP是啥？技术原理是什么？一个视频搞懂MCP的一切。Windows系统配置MCP，Cursor,Cline 使用MCP - YouTube</a></li>
  <li><a href="https://www.youtube.com/watch?v=x8LQC6ut53Y">How to use MCP servers from a custom AI agent (step by step) - YouTube</a></li>
  <li><a href="https://tenten.co/learning/claude-desktop-mcp/">Claude Desktop MCP 使用指南：完整設置教學</a></li>
</ul>]]></content><author><name>Your Name</name></author><category term="Tool" /><summary type="html"><![CDATA[最近Model Context Protocol（MCP）蔚為風潮，這篇文章嘗試簡單介紹一下並使用一個範例來實作看看。]]></summary></entry><entry><title type="html">Gradio Introduction</title><link href="https://wjohn1483.github.io/2025/02/22/gradio-introduction/" rel="alternate" type="text/html" title="Gradio Introduction" /><published>2025-02-22T00:00:00+00:00</published><updated>2025-02-22T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2025/02/22/gradio-introduction</id><content type="html" xml:base="https://wjohn1483.github.io/2025/02/22/gradio-introduction/"><![CDATA[<p>在做出了令人驚艷的模型或是功能以後，為了可以讓更多人使用，需要一個UI的介面來讓大家來操作，這邊簡單介紹一個可以快速透過python做出網頁UI的套件Gradio。</p>

<!--more-->

<h2 id="gradio">Gradio</h2>

<p><a href="https://www.gradio.app/">Gradio</a>是一個python的套件，讓使用者可以透過python來快速地創造出一個網頁來展示你所製作的模型或者是其他功能，在huggingface上面有許許多多的模型就是使用Gradio來展示給大家。</p>

<p>安裝的方式很簡單，可以直接透過pip來安裝</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">--upgrade</span> gradio
</code></pre></div></div>

<h2 id="簡單的範例">簡單的範例</h2>

<p>在安裝完成以後就可以著手來製作第一個簡單的網頁了，這邊可以來看一下<a href="https://www.gradio.app/guides/quickstart#building-your-first-demo">官方文件</a>裡面的第一個範例程式碼</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app.py
</span><span class="kn">import</span> <span class="n">gradio</span> <span class="k">as</span> <span class="n">gr</span>

<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">intensity</span><span class="p">):</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">Hello, </span><span class="sh">"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sh">"</span><span class="s">!</span><span class="sh">"</span> <span class="o">*</span> <span class="nf">int</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>

<span class="n">demo</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Interface</span><span class="p">(</span>
    <span class="n">fn</span><span class="o">=</span><span class="n">greet</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">slider</span><span class="sh">"</span><span class="p">],</span>
    <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">demo</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre></div></div>

<p>透過<code class="language-plaintext highlighter-rouge">python app.py</code>或是<code class="language-plaintext highlighter-rouge">gradio app.py</code>的方式來執行這個程式碼，兩者的差異在於<code class="language-plaintext highlighter-rouge">gradio app.py</code>會反應程式碼的改動，當你在開發的時候可以透過這個方式來開發，但開發完成以後建議使用<code class="language-plaintext highlighter-rouge">python app.py</code>的方式來host會比較好。</p>

<p>跑出來的結果會長得像下面的樣子，如果點上面官方文件的連結，可以直接在網站裡面與它互動看看</p>

<p><img src="first_demo.png" alt="First demo" /></p>

<p>在這邊我們透過字串的方式宣告了一個Interface的輸入和輸出，而且定義了一個python function <code class="language-plaintext highlighter-rouge">greet()</code>來去做邏輯的處理，需要注意<code class="language-plaintext highlighter-rouge">greet()</code>的argument的個數必須與inputs的個數相同，而<code class="language-plaintext highlighter-rouge">greet()</code>回傳的argument個數也必須與outputs的個數相同，在按下submit以後，<code class="language-plaintext highlighter-rouge">greet()</code>這個function會被執行，並將結果回傳到outputs當中，這時修改過後的文字就會出現在上方圖片右手邊的文字框裡面。</p>

<p>如果想要調整server的port，可以在<code class="language-plaintext highlighter-rouge">launch()</code>裡面加入相關的參數來設定。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">demo</span><span class="p">.</span><span class="nf">launch</span><span class="p">(</span><span class="n">server_name</span><span class="o">=</span><span class="sh">"</span><span class="s">0.0.0.0</span><span class="sh">"</span><span class="p">,</span> <span class="n">server_port</span><span class="o">=</span><span class="mi">8080</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="更細緻的操控">更細緻的操控</h3>

<p>在上面的例子裡面，我們使用了<code class="language-plaintext highlighter-rouge">Interface()</code>來幫助我們創建了一個簡單的UI出來，並指定了一個python function來處理對應的邏輯，如果你想要自行決定文字框和按鈕的排版、python function被觸發的條件，我們可以透過<code class="language-plaintext highlighter-rouge">Blocks()</code>來達成</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">gradio</span> <span class="k">as</span> <span class="n">gr</span>

<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">intensity</span><span class="p">):</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">Hello, </span><span class="sh">"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sh">"</span><span class="s">!</span><span class="sh">"</span> <span class="o">*</span> <span class="nf">int</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Blocks</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sh">"</span><span class="s">Hello Gradio</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">demo</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Row</span><span class="p">():</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Textbox</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">Name</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">intensity</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Slider</span><span class="p">(</span><span class="n">minimum</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">Intensity</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">submit_button</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Button</span><span class="p">(</span><span class="sh">"</span><span class="s">Submit</span><span class="sh">"</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="sh">"</span><span class="s">primary</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Textbox</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">Output</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">submit_button</span><span class="p">.</span><span class="nf">click</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">greet</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">intensity</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">output</span><span class="p">])</span>
    <span class="n">name</span><span class="p">.</span><span class="nf">change</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">greet</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">intensity</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">output</span><span class="p">])</span>
    <span class="n">intensity</span><span class="p">.</span><span class="nf">change</span><span class="p">(</span><span class="n">fn</span><span class="o">=</span><span class="n">greet</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">intensity</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">output</span><span class="p">])</span>

<span class="n">demo</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="first_demo_modified.png" alt="First demo modified" /></p>

<p>在上面的程式碼裡面，我們將<code class="language-plaintext highlighter-rouge">Interface()</code>替換成了<code class="language-plaintext highlighter-rouge">Blocks()</code>，並設定了網頁的名稱是<code class="language-plaintext highlighter-rouge">Hello Gradio</code>，同時引入了<code class="language-plaintext highlighter-rouge">Row()</code>，把在with clause底下的所有元件放在同一列裡面，而先前用字串指定的輸入輸出我們改成了gradio的物件來做更多的設定，最後對於每一個物件設定其觸發條件，<code class="language-plaintext highlighter-rouge">click()</code>為當按鈕被按下去的時候觸發，而<code class="language-plaintext highlighter-rouge">change()</code>為當元件的內容有被改變的時候就觸發，<code class="language-plaintext highlighter-rouge">Textbox()</code>還有像是<code class="language-plaintext highlighter-rouge">submit()</code>的觸發條件，當在文字框內按下enter就觸發等等，gradio有什麼元件以及各個元件有什麼可以設定及其觸發條件，可以參考<a href="https://www.gradio.app/docs/gradio/introduction">這邊的文件</a>。</p>

<h2 id="api的範例">API的範例</h2>

<p>除了使用網頁上面的UI來使用自己寫好的功能，Gradio還有提供API的方式來開放讓大家使用，我們可以透過<a href="https://www.gradio.app/guides/getting-started-with-the-python-client">python client</a>來呼叫前面寫好的<code class="language-plaintext highlighter-rouge">greet()</code> function</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">gradio_client</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="n">client</span> <span class="o">=</span> <span class="nc">Client</span><span class="p">(</span><span class="sh">"</span><span class="s">http://localhost:7860/</span><span class="sh">"</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">World</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">api_name</span><span class="o">=</span><span class="sh">"</span><span class="s">/greet</span><span class="sh">"</span>
<span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>這邊我們使用一個URL來初始化<code class="language-plaintext highlighter-rouge">Client()</code>這個物件，接著將function需要的輸入放進去，而API的名字會對應前面在設定觸發條件時，給定的python function，可以透過網頁UI最下方<code class="language-plaintext highlighter-rouge">Use via API</code>的按鈕來查看有哪些API可以被調用。</p>

<p>除了透過python client來使用以外，Gradio還可以<a href="https://www.gradio.app/guides/querying-gradio-apps-with-curl#authentication">使用一般的curl指令</a>來呼叫</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">EVENT_ID</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-X</span> POST http://localhost:7860/gradio_api/call/greet <span class="nt">-s</span> <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="nt">-d</span> <span class="s1">'{
  "data": ["World", 3]
}'</span> | <span class="nb">awk</span> <span class="nt">-F</span><span class="s1">'"'</span> <span class="s1">'{ print $4}'</span><span class="si">)</span>
curl <span class="nt">-N</span> http://localhost:7860/gradio_api/call/greet/<span class="k">${</span><span class="nv">EVENT_ID</span><span class="k">}</span>
</code></pre></div></div>

<p>這邊比較特別的地方是，使用curl並不像python client，直接呼叫就可以得到結果，而是會先用POST把資料餵進去以後拿到一個<code class="language-plaintext highlighter-rouge">event_id</code>，接著再用這個<code class="language-plaintext highlighter-rouge">event_id</code>透過GET的方式去取得跑出來的結果。</p>

<h2 id="動態的範例">動態的範例</h2>

<p>在前面的範例裡面，我們都是設定好固定的UI來讓使用者來使用，如果說想要讓UI隨著使用的的輸入而動態變化的話也是可以做到的，我們可以透過<code class="language-plaintext highlighter-rouge">@gr.render()</code>的方式來達成</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">gradio</span> <span class="k">as</span> <span class="n">gr</span>

<span class="k">def</span> <span class="nf">add_field</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fields</span> <span class="o">+</span> <span class="p">[{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="sh">"</span><span class="s">value</span><span class="sh">"</span><span class="p">:</span> <span class="n">value</span><span class="p">}],</span> <span class="sh">""</span><span class="p">,</span> <span class="sh">""</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Blocks</span><span class="p">()</span> <span class="k">as</span> <span class="n">web</span><span class="p">:</span>
        <span class="n">fields_state</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">State</span><span class="p">([])</span>
        <span class="k">with</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Row</span><span class="p">():</span>
            <span class="n">field_name_text</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Textbox</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">New field name</span><span class="sh">"</span><span class="p">)</span>
            <span class="n">field_value_text</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Textbox</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">New field value</span><span class="sh">"</span><span class="p">)</span>
            <span class="n">add_field_btn</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Button</span><span class="p">(</span><span class="sh">"</span><span class="s">Add</span><span class="sh">"</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">add_field_btn</span><span class="p">.</span><span class="nf">click</span><span class="p">(</span><span class="n">add_field</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">fields_state</span><span class="p">,</span> <span class="n">field_name_text</span><span class="p">,</span> <span class="n">field_value_text</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">fields_state</span><span class="p">,</span> <span class="n">field_name_text</span><span class="p">,</span> <span class="n">field_value_text</span><span class="p">])</span>

        <span class="nd">@gr.render</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">fields_state</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">render_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Row</span><span class="p">():</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Textbox</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">Name</span><span class="sh">"</span><span class="p">)</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Textbox</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="sh">"</span><span class="s">value</span><span class="sh">"</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">Value</span><span class="sh">"</span><span class="p">)</span>
                    <span class="n">update_btn</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Button</span><span class="p">(</span><span class="sh">"</span><span class="s">Update</span><span class="sh">"</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">delete_btn</span> <span class="o">=</span> <span class="n">gr</span><span class="p">.</span><span class="nc">Button</span><span class="p">(</span><span class="sh">"</span><span class="s">Delete</span><span class="sh">"</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="sh">"</span><span class="s">stop</span><span class="sh">"</span><span class="p">)</span>
                    <span class="k">def</span> <span class="nf">delete_field</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">):</span>
                        <span class="n">fields</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">fields</span>
                    <span class="k">def</span> <span class="nf">update_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                        <span class="n">new_fields</span> <span class="o">=</span> <span class="nf">delete_field</span><span class="p">()</span>
                        <span class="k">return</span> <span class="n">new_fields</span> <span class="o">+</span> <span class="p">[{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="sh">"</span><span class="s">value</span><span class="sh">"</span><span class="p">:</span> <span class="n">value</span><span class="p">}]</span>
                    <span class="n">update_btn</span><span class="p">.</span><span class="nf">click</span><span class="p">(</span><span class="n">update_field</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="n">fields_state</span><span class="p">)</span>
                    <span class="n">delete_btn</span><span class="p">.</span><span class="nf">click</span><span class="p">(</span><span class="n">delete_field</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">fields_state</span><span class="p">)</span>

    <span class="n">web</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">main</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="dynamic_demo.png" alt="Dynamic demo" /></p>

<p>在<code class="language-plaintext highlighter-rouge">gr.Blocks()</code>的第一段裡面，我們宣告了一個<code class="language-plaintext highlighter-rouge">gr.State()</code>，裡面存放的是一個python list，同時做了兩個<code class="language-plaintext highlighter-rouge">Textbox()</code>，讓使用可以輸入<code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">value</code>，並加入一個按鈕來去將使用者輸入的name、value pair放到state裡面。</p>

<p>接著我們透過<code class="language-plaintext highlighter-rouge">gr.render()</code>，並以前面的state當作輸入，根據state裡面儲存的list的資訊去產生對應的元件出來，於此同時我們也可以對新產生出來的元件去設定其觸發的條件，進而更新state裡面的資訊，如此便可以動態地新增、移除網頁上面的元件了。</p>

<p>這邊的邏輯可以想成是，當我們在根據拿到的field_state並產生Textbox的時候，順便把當下的field當作default argument存到button點擊的function裡面，而這個button被點擊的時候才會執行被放到button的function，如此我們就可以在執行的時候還可以保有前一個時刻的field來做到更多的功能應用。</p>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li><a href="https://blog.csdn.net/cxyhjl/article/details/139712016">【Gradio】Building With Blocks 块中的状 态 + 动态应用程序与渲染装饰器-CSDN博客</a></li>
</ul>]]></content><author><name>Your Name</name></author><category term="Tool" /><summary type="html"><![CDATA[在做出了令人驚艷的模型或是功能以後，為了可以讓更多人使用，需要一個UI的介面來讓大家來操作，這邊簡單介紹一個可以快速透過python做出網頁UI的套件Gradio。]]></summary></entry><entry><title type="html">Spark Introduction</title><link href="https://wjohn1483.github.io/2024/08/07/spark-introduction/" rel="alternate" type="text/html" title="Spark Introduction" /><published>2024-08-07T00:00:00+00:00</published><updated>2024-08-07T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2024/08/07/spark-introduction</id><content type="html" xml:base="https://wjohn1483.github.io/2024/08/07/spark-introduction/"><![CDATA[<p>這篇文章記錄一下最近學習到對於spark執行上的理解。</p>

<!--more-->

<h2 id="spark的基本架構">Spark的基本架構</h2>

<p><img src="https://i0.wp.com/sparkbyexamples.com/wp-content/uploads/2023/03/Driver-2.jpg?w=731&amp;ssl=1" alt="Spark architecture" /></p>

<p><em><a href="https://sparkbyexamples.com/spark/what-is-spark-job/">What is Spark Job - Spark By {Examples}</a></em></p>

<p>Spark的基本架構長得如上圖，當我們提交一個spark application給cluster manager像是yarn以後，application首先會先被交由一個driver來執行，driver可以想成是在cluster內某一個instance上的process，而這個process會根據你寫的程式碼去要求cluster manager給予executor來去執行對應的任務。</p>

<p><img src="https://i0.wp.com/sparkbyexamples.com/wp-content/uploads/2023/03/spark-Stage-1.jpg?w=711&amp;ssl=1" alt="Spark stage" /></p>

<p><em><a href="https://sparkbyexamples.com/spark/what-is-spark-stage/">What is Spark Stage? Explained - Spark By {Examples}</a></em></p>

<p>一個application通常會根據你寫的程式碼又被細分成好幾個job和stage，一個job會被產生是當你對dataframe或是rdd採取一些特定的action像是<code class="language-plaintext highlighter-rouge">count()</code>、<code class="language-plaintext highlighter-rouge">collect()</code>、<code class="language-plaintext highlighter-rouge">write()</code>等，而每個job底下又可能有好幾個stage，端看你這個action需不需要shuffle、與其他instance傳輸資料，最後的每一個task就是實際上會丟到executor上執行的資料partition。</p>

<h2 id="如何計算spark-application需要多少資源">如何計算Spark Application需要多少資源</h2>

<p>這邊我們需要先區分一下instance和executor，instance是你這個cluster裡面實際的機器，而executor是spark用來執行task的process，所以在一個instance上面有可能會被分配到一個或多個executor，根據你機器的規格和executor對於core和memory的要求來決定。</p>

<p>而每一個task會交由一個core來執行，所以當一個executor有4個核心的時候，spark會以multi-thread的方式來平行化地執行4個task，如果task裡面有包含到python udf，那麼會在每一個核心上面長一個python執行器，由每個核心的python執行器來執行udf。</p>

<p>值得一提的是，spark好像只會看instance的核心數來分配executor，如果你的executor需要很多memory，需要小心造成OOM，舉例來說假設一個instance上面有16個core、64GB的記憶體，而我們設定<code class="language-plaintext highlighter-rouge">spark.executor.cores=2</code>、<code class="language-plaintext highlighter-rouge">spark.executor.memory=16g</code>，這時spark會覺得這個instance有機會可以放16/2=8個executor，但由於memory的關係其實最多只能放4個，如果8個都放上去就有可能造成問題，需要設定<code class="language-plaintext highlighter-rouge">spark.executor.instances</code>來限制executor的數量。</p>

<h2 id="為什麼python-udf會被執行多次">為什麼python udf會被執行多次</h2>

<p>PySpark執行python udf的方式是會先把拿到的資料partition再切成好幾個batch，把每個batch轉換成PyArrow的格式以後交由python執行器來執行，而現在pandas udf支援透過iterator的方式來存取，spark會把每一個batch的iterator丟進python執行器來跑udf，這時如果udf有一些比較吃重的初始化工作的時候，就可以寫在iterator前，之後就可以透過iterator來吃資料，不用再重新初始化一次。</p>

<p>如果我們透過Spark UI去看每一個task的log的時候，可能還是會發現udf裡面初始化的部分被執行了多次，這邊有幾種可能，一個可能是因為executor有多個核心、使用multi-thread執行，所以同一個executor上不同task的log被混在一起，另一個可能是spark沒有把結果保留下來，後面又重算了一次，原因可能是job和job之間做了其他事情，executor需要釋放記憶體去執行其他的任務，當後面的job又需要前面job計算的結果時導致重算，我們可以透過<code class="language-plaintext highlighter-rouge">cache()</code>、<code class="language-plaintext highlighter-rouge">persist()</code>來讓spark強制把結果儲存下來，避免重算的發生。</p>

<p>在一個<a href="https://stackoverflow.com/questions/58696198/spark-udf-executed-many-times">StackOverflow的討論串</a>上面有提供另一個方式是把udf設定成<code class="language-plaintext highlighter-rouge">Nondeterministic</code>，讓spark只執行一次這個udf，或許也可以試試看，但如果後面需要重算，這個做法還是會讓udf被執行多次。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@pandas_udf</span><span class="p">(...)</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">test</span> <span class="o">=</span> <span class="n">test</span><span class="p">.</span><span class="nf">asNondeterministic</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li>
    <p><a href="https://sparkbyexamples.com/spark/what-is-spark-job/">What is Spark Job - Spark By {Examples}</a></p>
  </li>
  <li>
    <p><a href="https://sparkbyexamples.com/spark/what-is-spark-stage/">What is Spark Stage? Explained - Spark By {Examples}</a></p>
  </li>
  <li>
    <p><a href="https://sparkbyexamples.com/spark/spark-tune-executor-number-cores-and-memory/">Tune Spark Executor Number, Cores, and Memory - Spark By {Examples}</a></p>
  </li>
</ul>]]></content><author><name>Your Name</name></author><category term="Spark" /><summary type="html"><![CDATA[這篇文章記錄一下最近學習到對於spark執行上的理解。]]></summary></entry><entry><title type="html">Diffusion Model介紹</title><link href="https://wjohn1483.github.io/2024/08/03/introduction-to-diffusion-model/" rel="alternate" type="text/html" title="Diffusion Model介紹" /><published>2024-08-03T00:00:00+00:00</published><updated>2024-08-03T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2024/08/03/introduction-to-diffusion-model</id><content type="html" xml:base="https://wjohn1483.github.io/2024/08/03/introduction-to-diffusion-model/"><![CDATA[<p>這篇文章來記錄一下學習diffusion model的筆記。</p>

<!--more-->

<p>在過去如果要讓機器產生圖片，通常會使用VAE或是GAN的方法來產生，而後來出現了diffusion model，產圖的效果很好，近期幾乎所有產圖的模型都是基於diffusion model來設計的。</p>

<h2 id="diffusion-model的運作原理">Diffusion Model的運作原理</h2>

<p>Diffusion model的想法可以想成是我們去訓練一個noise predictor，輸入一張圖片，去預測圖片當中有哪些部分是雜訊，接下來就是將原始圖片減去noise predictor預測出來的雜訊來獲得新的圖片</p>

<pre><code class="language-mermaid">graph LR;
    image1(Image)
    image2(New image)
    denoise[Noise predictor]
    noise(Noise)
    minus(Minus)
    image1--&gt;denoise
    denoise--&gt;noise
    image1--&gt;minus
    noise--&gt;minus
    minus--&gt;image2
</code></pre>

<p>我們可以從一張隨機分佈上面抽樣出來的圖片，反覆上面的動作來獲得一張清晰的圖片，有點類似米開朗基羅雕塑大衛像，雕像已經在石頭裡面了，只是把多餘的部分拿掉。</p>

<pre><code class="language-mermaid">graph LR;
    image1(Image T)
    denoise1[Denoise]
    image2(Image T-1)
    denoise2[Denoise]
    image3(Image T-2)
    denoise3[Denoise]
    image_final(Image 1)
    image1--&gt;denoise1
    denoise1--&gt;image2
    image2--&gt;denoise2
    denoise2--&gt;image3
    image3--&gt;denoise3
    denoise3--Many steps later--&gt;image_final
</code></pre>

<p>具體在訓練這個noise predictor的時候，我們會把當下是第幾步也放進noise predictor當中</p>

<pre><code class="language-mermaid">graph LR;
    image1(Image 1000)
    step1(1000)
    denoise1[Denoise]
    image2(Image 999)
    step2(999)
    denoise2[Denoise]
    image3(Image 998)
    image1--&gt;denoise1
    step1--&gt;denoise1
    denoise1--&gt;image2
    image2--&gt;denoise2
    step2--&gt;denoise2
    denoise2--&gt;image3
</code></pre>

<p>可以想像在剛開始從都是雜訊的圖片需要去除雜訊的時候，消除雜訊的力道需要比較大一些，而到後面圖片已經成形以後，消除雜訊的力道就可以不用這麼大了，因為需要把當下的步數給noise predictor當作輸入。</p>

<p>而訓練資料的取得方法也相對簡單，從網路上找到各式各樣的圖片以後，往圖片裡面加入noise就取得了一組paired data，被加入noise的圖片是noise predictor的輸入，而加進去的noise便是noise predictor的label。</p>

<h2 id="文字生成圖片">文字生成圖片</h2>

<p>在上面的部分我們是直接從都是雜訊的圖片裡面去產生一張清晰的圖片，如果想要產生出來的圖片能跟我們給予的文字敘述相符合，通常的做法像底下這樣</p>

<pre><code class="language-mermaid">graph LR;
    text(Text)
    encoder[Text encoder]
    diffusion[Text-to-Image diffusion]
    random(Random noise)
    decoder[Image decoder]
    image(Image)
    text--text representation--&gt;encoder
    encoder--&gt;diffusion
    random--&gt;diffusion
    diffusion--image latent representation--&gt;decoder
    decoder--&gt;image
</code></pre>

<p>首先會有一個Text encoder把使用者給予的文字轉換成vector，而這個vector會在text-to-image的diffusion model裡面在產生圖片的時候被使用到，最後是一個image decoder model，專門把diffusion model產生出來的tensor轉換成圖片，在前面diffusion model當中，我們可以直接產生圖片也可以讓後面的decoder產生，在目前的研究中看起來，分成兩步驟，讓decoder產生圖片的效果是比較好的。</p>

<h3 id="text-encoder">Text Encoder</h3>

<p>這邊text encoder的目標是把敘述轉換成vector，我們可以直接使用已經訓練好的語言模型像是BERT、GPT來幫助我們將文字轉換成向量。</p>

<h3 id="image-decoder">Image Decoder</h3>

<p>Image decoder做的事情是將diffusion model產生出來的向量或是小圖片轉換成大圖片，這邊我們可以去網路上搜尋各式各樣的圖片，透過訓練一個VAE來獲得這個image decoder，因為VAE可以不需要文字和圖片成對的資料，所以有機會可以用很多圖片來得到一個比較好的decoder。</p>

<h3 id="diffusion">Diffusion</h3>

<p>在diffusion的部分，大致上的做法跟上面雷同，比較不一樣的是因為我們想要根據使用者輸入的文字來產生圖片，所以在noise predictor的每一步都會把text encoder做出來的文字向量輸入給noise predictor。</p>

<p>如果diffusion model最後的輸出是latent representation，當我們在把成對的圖片和文字拿來訓練diffusion model的時候，我們可以使用VAE的encoder把圖片轉換成tensor，而上方diffusion model的中間產物也會從圖片變成tensor，亦即noise predictor在預測的就不是圖片上的noise，而是圖片的latent representation的noise。</p>

<h2 id="結論">結論</h2>

<p>這篇文章簡單介紹了一下diffusion model的概念以及text to image所會使用到的模組，但如果實際上去看stable diffusion的演算法會發現跟上面的說法有一些出入，詳細的數學可以參考<a href="https://www.youtube.com/watch?v=ifCDXFdeaaM&amp;list=PLJV_el3uVTsNi7PgekEUFsyVllAJXRsP-&amp;index=4">這邊的影片</a>。</p>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li><a href="https://www.youtube.com/playlist?list=PLJV_el3uVTsNi7PgekEUFsyVllAJXRsP-">Diffusion Model - YouTube</a></li>
</ul>]]></content><author><name>Your Name</name></author><category term="Computer-Vision" /><summary type="html"><![CDATA[這篇文章來記錄一下學習diffusion model的筆記。]]></summary></entry><entry><title type="html">架設Elasticsearch來搜尋log</title><link href="https://wjohn1483.github.io/2024/05/24/elasticsearch/" rel="alternate" type="text/html" title="架設Elasticsearch來搜尋log" /><published>2024-05-24T00:00:00+00:00</published><updated>2024-05-24T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2024/05/24/elasticsearch</id><content type="html" xml:base="https://wjohn1483.github.io/2024/05/24/elasticsearch/"><![CDATA[<p>這篇文章記錄一下如何架設一個etlasticsearch的伺服器來儲存log，好方便使用者來做搜尋。</p>

<!--more-->

<p><a href="https://www.elastic.co/">Elasticsearch</a>是一個開源的搜尋系統，使用者可以將檔案或是文字透過RESTful API的方式上傳到elasticsearch上做index，接著一樣透過RESTful API的方式來根據使用者設定的條件來取得對應的文件，這篇文章會介紹一下如何透過docker架設一個elasticsearch伺服器，並搭配Kibana和Filebeat來監控路徑下的檔案並透過UI來操作。</p>

<h2 id="架設elasticsearch">架設Elasticsearch</h2>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html">架設Elasticsearch</a>的方式有很多種，一個比較簡單的方式是直接去抓docker image下來</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create elastic
docker pull docker.elastic.co/elasticsearch/elasticsearch:8.13.4
<span class="nb">sudo </span>sysctl <span class="nt">-w</span> vm.max_map_count<span class="o">=</span>262144
docker run <span class="nt">--name</span> es01 <span class="nt">--net</span> elastic <span class="nt">-p</span> 9200:9200 <span class="nt">-it</span> <span class="nt">-m</span> 1GB docker.elastic.co/elasticsearch/elasticsearch:8.13.4
</code></pre></div></div>

<p>上面的指令會創建一個叫<code class="language-plaintext highlighter-rouge">elastic</code>的網路，之後創建的container都會放在這個網路底下，而在執行<code class="language-plaintext highlighter-rouge">docker run</code>以後，最後會停在一個畫面，上會顯示使用者<code class="language-plaintext highlighter-rouge">elastic</code>的密碼，以及Kibana的enrollment token，我們需要將這個密碼存下來，在之後要使用UI或是打API時都會使用到。</p>

<p>如果想要測試elasticsearch有沒有順利地被建立起來，可以透過底下的指令試打看看</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">ELASTIC_PASSWORD</span><span class="o">=</span><span class="s2">"YOUR_PASSWORD_HERE"</span>
docker <span class="nb">cp </span>es01:/usr/share/elasticsearch/config/certs/http_ca.crt <span class="nb">.</span>
curl <span class="nt">--cacert</span> http_ca.crt <span class="nt">-u</span> elastic:<span class="k">${</span><span class="nv">ELASTIC_PASSWORD</span><span class="k">}</span> https://localhost:9200
</code></pre></div></div>

<p>要跟elasticsearch溝通除了需要帳號密碼以外，我們還需要一個http certificate，這邊可以直接從container裡面複製出來。</p>

<h2 id="架設kibana">架設Kibana</h2>

<p>Kibana是用來跟Elasticsearch互動的UI介面，一樣也可以透過docker來建立</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull docker.elastic.co/kibana/kibana:8.13.4
docker run <span class="nt">--name</span> kib01 <span class="nt">--net</span> elastic <span class="nt">-p</span> 5601:5601 docker.elastic.co/kibana/kibana:8.13.4
</code></pre></div></div>

<p>這時使用瀏覽器連線到<a href="http://localhost:5601">http://localhost:5601</a>應該就可以看到kibana的介面了，畫面上會顯示要你填入enrollment token，把上方elasticsearch顯示的enrollment token直接填入就可以讓兩者順利連線了。</p>

<h2 id="上傳document">上傳Document</h2>

<p>在建立好elasticsearch和kibana以後，接著就可以把我們想要從中搜尋的文件給上傳上去了，elasticsearch提供了很多方式可以上傳，這邊介紹如何透過python和filebeat來上傳。</p>

<h3 id="使用python上傳document">使用Python上傳Document</h3>

<p>首先我們需要先安裝elasticsearch的套件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>elasticsearch
</code></pre></div></div>

<p>接著就可以透過python來連線到elasticsearch了</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">elasticsearch</span> <span class="kn">import</span> <span class="n">Elasticsearch</span>

<span class="n">es</span> <span class="o">=</span> <span class="nc">Elasticsearch</span><span class="p">(</span><span class="sh">"</span><span class="s">https://localhost:9200</span><span class="sh">"</span><span class="p">,</span>
                   <span class="n">basic_auth</span><span class="o">=</span><span class="p">(</span><span class="sh">"</span><span class="s">elastic</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">YOUR_PASSWORD_HERE</span><span class="sh">"</span><span class="p">),</span>
                   <span class="n">ca_certs</span><span class="o">=</span><span class="sh">"</span><span class="s">./http_ca.crt</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>這邊需要提供elasticsearch所架設的位置、帳號密碼和http certificate的路徑來建立連線。</p>

<p>下一步便是建立一個elasticsearch的index，好把我們想要搜尋的document放進這個index裡面</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">es</span><span class="p">.</span><span class="n">indices</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="sh">"</span><span class="s">YOUR_INDEX_NAME</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># es.indices.delete(index="YOUR_INDEX_NAME", ignore=[400, 404])
</span></code></pre></div></div>

<p>如果想要刪除，重新建立index的話，可以使用上面<code class="language-plaintext highlighter-rouge">delete</code>的function來把整個index刪掉。</p>

<p>最後就是將document上傳上去</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">es</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span>
    <span class="n">index</span><span class="o">=</span><span class="sh">"</span><span class="s">YOUR_INDEX_HERE</span><span class="sh">"</span><span class="p">,</span>
    <span class="nb">id</span><span class="o">=</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">document_id</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">document</span><span class="o">=</span><span class="p">{</span>
        <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">document_name</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>這邊我們上傳了一個document，其id是<code class="language-plaintext highlighter-rouge">f"{document_id}"</code>，底下有一個field是<code class="language-plaintext highlighter-rouge">name</code>，其對應的value是<code class="language-plaintext highlighter-rouge">f"{document_name}"</code>，這裡可以根據你對document的理解和處理來新增多個field，但id只能有一個。</p>

<p>這時，在Kibana上面做仿側邊欄的<strong>Search→Content</strong>裡面應該就能看到你上傳上去的index和document了，如果想透過python來query的話，可以使用下面的方式透過document name來搜尋</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="n">es</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="sh">"</span><span class="s">YOUR_INDEX_HERE</span><span class="sh">"</span><span class="p">,</span>
                     <span class="n">body</span><span class="o">=</span><span class="p">{</span>
                         <span class="sh">"</span><span class="s">query</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
                             <span class="sh">"</span><span class="s">match</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
                                 <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">document_name</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span>
                             <span class="p">}</span>
                         <span class="p">}</span>
                     <span class="p">})</span>
</code></pre></div></div>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-with-elasticsearch.html">Elasticsearch還有提供多種方式</a>來做搜尋，如果需要的話可以再自行研究。</p>

<h3 id="使用filebeat上傳document">使用Filebeat上傳Document</h3>

<p>上面使用python的方式是我們主動將document上傳到elasticsearch上，另一個方式是使用filebeat去監聽特定路徑下的檔案更動，如果有新的更動就將新的資料上傳到elastcissearch上，filebeat是<a href="https://www.elastic.co/logstash">Logstash</a>裡面比較輕量化的檔案監聽套件，如果需求比較複雜的話可以嘗試使用Logstash看看。</p>

<p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-installation-configuration.html">安裝filebeat的方式</a>有很多種方法，底下使用的是rpm的安裝方式</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-L</span> <span class="nt">-O</span> https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.13.4-x86_64.rpm
<span class="nb">sudo </span>rpm <span class="nt">-vi</span> filebeat-8.13.4-x86_64.rpm
</code></pre></div></div>

<p>安裝好以後，我們可以打開<code class="language-plaintext highlighter-rouge">/etc/filebeat/filebeat.yml</code>來設定filebeat，首先需要設定filebeat連接到elasticsearch，在<code class="language-plaintext highlighter-rouge">output.elasticsearch</code>的區塊改成底下的設定</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">output.elasticsearch</span><span class="pi">:</span>
  <span class="na">hosts</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">https://localhost:9200"</span><span class="pi">]</span>
  <span class="na">preset</span><span class="pi">:</span> <span class="s">balanced</span>
  <span class="na">prototol</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https"</span>
  <span class="na">username</span><span class="pi">:</span> <span class="s2">"</span><span class="s">elastic"</span>
  <span class="na">password</span><span class="pi">:</span> <span class="s2">"</span><span class="s">${ES_PASS}"</span>
  <span class="na">ssl.certificate_authorities</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">/path/to/your/certificate"</span><span class="pi">]</span>
</code></pre></div></div>

<p>這邊的<code class="language-plaintext highlighter-rouge">${ES_PASS}</code>是存放在filebeat keystore的變數，如果直接把密碼寫在yml裡面會有洩漏的風險，<a href="https://www.elastic.co/guide/en/beats/filebeat/8.13/keystore.html">filebeat提供了keystore的功能</a>讓你把機密資訊存起來，使用的方式是先建立keystore</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filebeat keystore create
</code></pre></div></div>

<p>接著就能透過底下的指令來設定變數</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filebeat keystore add ES_PASS
</code></pre></div></div>

<p>再來我們就可以跳到<code class="language-plaintext highlighter-rouge">filebeat.inputs</code>的地方來設定要監聽的路徑，底下是一個簡單的模板</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">filebeat.inputs</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">filestream</span>
  <span class="na">id</span><span class="pi">:</span> <span class="s">your_input_id</span>
  <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">paths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">/path/to/your/logs</span>
    <span class="c1"># e.g. - /var/log/*.log</span>
  <span class="c1"># json.keys_under_root: true</span>
  <span class="c1"># json.add_error_key: true</span>
  <span class="na">index</span><span class="pi">:</span> <span class="s2">"</span><span class="s">your_index"</span>
</code></pre></div></div>

<p>如果想要監聽其他路徑的檔案並放到不同的index裡面，只需要再另外加一個<code class="language-plaintext highlighter-rouge">type</code>的區塊就可以了，這邊我們需要設定這個input的id、要監聽的路徑以及想要放到elasticsearch的哪個index裡面。</p>

<p>設定好以後，執行底下的指令讓filebeat跑起來，就可以在Kibana上面看到filebeat上傳的index了，在左邊側邊欄裡面的<strong>Management→Stack Management→Index Management</strong>也可以看到相關的設定。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filebeat <span class="nt">-e</span>
</code></pre></div></div>

<p>如果在上傳的時候發現問題，想讓filebeat重新上傳整個index，除了在kibana裡面砍掉index外，我們需要把底下的資料夾也砍掉，讓filebeat忘記過去曾經上傳過的東西以後，重啟filebeat的服務來整個重新上傳。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/var/lib/filebeat/registry
</code></pre></div></div>

<h4 id="parse-json-log">Parse json log</h4>

<p>Filebeat預設會是一行一行地讀取路徑底下的檔案，如果這個檔案是紀錄json的log，每一行是一個json object的話，我們可以在<code class="language-plaintext highlighter-rouge">filebeat.inputs</code>多加<code class="language-plaintext highlighter-rouge">json.keys_under_root</code>和<code class="language-plaintext highlighter-rouge">json.add_error_key</code>來讓filebeat幫我們去parse json的log。</p>

<p>這時如果去kibana上面看會發現到filebeat把整個json object放到<code class="language-plaintext highlighter-rouge">message</code>這個field裡面，沒有把json的key、value塞到對應的field</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">processors</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">decode_json_fields</span><span class="pi">:</span>
    <span class="na">fields</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">message"</span><span class="pi">]</span>
    <span class="na">process_array</span><span class="pi">:</span> <span class="kc">false</span>
    <span class="na">max_depth</span><span class="pi">:</span> <span class="m">2</span>
    <span class="na">target</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">overwrite_keys</span><span class="pi">:</span> <span class="kc">true</span>
    <span class="na">add_error_key</span><span class="pi">:</span> <span class="kc">false</span>
</code></pre></div></div>

<p>我們還需要在<code class="language-plaintext highlighter-rouge">/etc/filebeat/filebeat.yml</code>裡面<code class="language-plaintext highlighter-rouge">processors</code>的區塊多加<code class="language-plaintext highlighter-rouge">decode_json_fields</code>來明確地告訴filebeat我們想要解析<code class="language-plaintext highlighter-rouge">message</code>這個field，設定好並重啟filebeat的服務以後就可以在kibana上面看到json object裡面的key、value被塞進elasticsearch index裡document的field了。</p>

<h2 id="參考資料">參考資料</h2>

<ul>
  <li>
    <p><a href="https://ithelp.ithome.com.tw/users/20130639/ironman/3747">親愛的，我把ElasticSearch上雲了 :: 第 12 屆 iThome 鐵人賽</a></p>
  </li>
  <li>
    <p><a href="https://www.cnblogs.com/zsql/p/13137833.html"> 一篇文章搞懂filebeat（ELK）</a></p>
  </li>
</ul>]]></content><author><name>Your Name</name></author><category term="Tool" /><summary type="html"><![CDATA[這篇文章記錄一下如何架設一個etlasticsearch的伺服器來儲存log，好方便使用者來做搜尋。]]></summary></entry><entry><title type="html">如何安裝Comfy UI</title><link href="https://wjohn1483.github.io/2024/04/17/comfy-ui/" rel="alternate" type="text/html" title="如何安裝Comfy UI" /><published>2024-04-17T00:00:00+00:00</published><updated>2024-04-17T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2024/04/17/comfy-ui</id><content type="html" xml:base="https://wjohn1483.github.io/2024/04/17/comfy-ui/"><![CDATA[<p>先前介紹了如何<a href="https://wjohn1483.github.io/2023/07/02/stable-diffusion/">在本機上面跑Stable Diffusion</a>，這篇文章來記錄一下如何安裝Comfy UI，來讓產圖變得更容易。</p>

<!--more-->

<h2 id="comfy-ui">Comfy UI</h2>

<p><a href="https://github.com/comfyanonymous/ComfyUI">Comfy UI</a>是個使用stable diffusion產圖，但把介面變成流程圖的方式來呈現，方便使用者可以一目了然地理解產圖的過程，還可以直接在上面調整prompt和參數。</p>

<h2 id="安裝流程">安裝流程</h2>

<h3 id="安裝comfy-ui">安裝Comfy UI</h3>

<p>首先先從<a href="https://github.com/comfyanonymous/ComfyUI">GitHub</a>上面把Comfy UI clone下來，接下來安裝python相關的套件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install</span> <span class="nt">-r</span> requirements.txt
</code></pre></div></div>

<h3 id="下載模型">下載模型</h3>

<p>在有了UI以後，我們還需要去下載其背後所使用到的stable diffusion的模型們，我們可以在<a href="https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0/tree/main">huggingface</a>上面下載到，至少會需要模型本身的safetensors，如果有更新的模型也可以下載最新的。將下載下來的safetensors檔案放在clone下來repository的<strong>models/checkpoints</strong>即可。</p>

<h3 id="執行comfy-ui">執行Comfy UI</h3>

<p>只要下底下的指令，理論上就可以順利地跑起來了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Use GPU</span>
python3 main.py

<span class="c"># Use CPU only</span>
python3 main.py <span class="nt">--cpu</span>
</code></pre></div></div>

<p>預設的port是8188，所以打開瀏覽器連上<code class="language-plaintext highlighter-rouge">http://localhost:8188</code>應該就能看到使用者介面了。</p>

<p><img src="./comfyui.png" alt="Comfy UI" /></p>

<p>上面的文字框可以填上你想要用來產生圖片的prompt，而下面的文字框是填上你不想要在圖片中看到的prompt，記得在左邊的Checkpoint區塊選擇你下載下來的模型，最後按下<code class="language-plaintext highlighter-rouge">Queue Prompt</code>就可以產圖了。</p>

<h3 id="上傳pipeline">上傳pipeline</h3>

<p>基本版的pipeline雖然挺好用的，但網路上有更多更厲害的pipeline，這邊舉<a href="https://github.com/SytanSD/Sytan-SDXL-ComfyUI/blob/main/Sytan's%20SDXL%201.0%20Workflow%20.json">Sytan-SDXL-ComfyUI</a>為例子，直接從GitHub上面把json下載下來Load到Comfy UI上面就可以使用了。</p>

<h2 id="comfyui-manager">ComfyUI-Manager</h2>

<p>隨著Comfy UI的盛行，有越來越多人寫了一些其他的套件來擴充現有Comfy UI的功能，我們可以透過ComfyUI-Manager來安裝其他實用的套件，安裝的方法很簡單，在前面clone下來的Comfy UI repository裡面下底下的指令就可以了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>custom_nodes
git clone https://github.com/ltdrdata/ComfyUI-Manager.git
<span class="c"># Restart Comfy UI</span>
</code></pre></div></div>

<p>重啟Comfy UI以後就可以看到右邊選單列表內多了<code class="language-plaintext highlighter-rouge">Manager</code>的按鈕可以點選，在裡面可以搜尋各式各樣的套件來安裝。</p>

<h3 id="comfyspace">Comfyspace</h3>

<p>在眾多的套件裡面，推薦可以先安裝<a href="https://github.com/11cafe/comfyui-workspace-manager">ComfySpace</a>，在Manager裡面搜尋<code class="language-plaintext highlighter-rouge">ComfyUI Workspace Manager</code>，接著重啟Comfy UI就可以了，其功用是幫你記錄和尋找Comfy UI的pipeline，如此就可以不用自己存pipeline的json，增加產圖的效率。</p>]]></content><author><name>Your Name</name></author><category term="Tool" /><summary type="html"><![CDATA[先前介紹了如何在本機上面跑Stable Diffusion，這篇文章來記錄一下如何安裝Comfy UI，來讓產圖變得更容易。]]></summary></entry><entry><title type="html">Bandit Algorithms Notes</title><link href="https://wjohn1483.github.io/2024/02/22/bandit-algorithms-notes/" rel="alternate" type="text/html" title="Bandit Algorithms Notes" /><published>2024-02-22T00:00:00+00:00</published><updated>2024-02-22T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2024/02/22/bandit-algorithms-notes</id><content type="html" xml:base="https://wjohn1483.github.io/2024/02/22/bandit-algorithms-notes/"><![CDATA[<p>最近剛好有機會碰了一下一直聽過但都沒有實際碰過的Bandit Algorithms，這邊紀錄一下從網路上學習到的知識。</p>

<!--more-->

<p>Bandit算法一開始被設計出來是為了要解決在有限的資源下要如何創造最大的收益，網路文章中給的例子通常都是在一個滿是吃角子老虎機台的房間當中，如何用手中有限的籌碼獲得最大的報酬，也就是找到獲獎機率比較大的吃角子老虎機台，這時候使用者會面臨繼續玩原本預期收益最大的吃角子老虎機，或是去玩看看新的吃角子老虎機，也就是在exploitation和exploration兩者之間抉擇。</p>

<p>在原本的Multi-Armed Bandit裡面，我們只考慮不同吃角子老虎的機台，並沒有考慮使用者本身的偏好，像是某個使用者可能特別偏好某個有特殊外型的吃角子老虎機，對於該使用者而言那台吃角子老虎機的預期收益會比較大，如果有考慮到使用者本身資訊的bandit通常被稱為contextual bandit，反之被稱為context-free bandit。</p>

<p>在任何的一個bandit algorithm裡面，我們會對每一個arm，也就是每一個吃角子老虎機台打一個分數，並從這些機台裡面選一個分數最高的去使用，而不同的算法會有不同打分數的方式，比較著名的context-free bandit的算法有UCB、Thompson Sampling，比較著名的contextual bandit算法有LinUCB。</p>

<h2 id="epsilon-greedy">Epsilon Greedy</h2>

<p>在進到Bandit的算法之前，我們可以先用一個簡單的方法來平衡exploitation和exploration，我們可以每次在決定要玩哪台吃角子老虎機的時候先擲一個骰子，令其有$\epsilon$的機率會去選擇以前沒有玩過的吃角子老虎機試試看，反之就繼續玩目前玩過的所有吃角子老虎機裡面，預期收益最大的。</p>

<h2 id="upper-confidence-bound-ucb">Upper Confidence Bound (UCB)</h2>

<p>在使用epsilon greedy做exploration的時候，每一個arm被選中的機會是相等的，但實際上每一個arm曾經被看過的次數和互動過的次數都不同，在exploration的時候可以有更聰明一點的方法，而UCB的概念是對於每一個arm給予的分數是基於它有可能所帶來的最高報酬，其分數的公式如下</p>

\[\mu_i+\sqrt{\frac{2\ln (n)}{n_i}}\]

<p>$\mu_i$是每一個$arm_i$前n次嘗試獲得的平均報酬，$n$是總嘗試次數，$n_i$是$arm_i$被嘗試的次數。</p>

<p>左邊這項可以理解成過去這個$arm_i$所能夠帶給我們的平均報酬是多少，展現的是exploitation的部分，而右邊這項會讓比較少曝光的$arm_i$有比較高的分數，令其有機會被展示出來，展現的是exploration的部分。</p>

<h2 id="thompson-sampling">Thompson Sampling</h2>

<p>Thompson sampling的想法是，每次使用同一個arm所獲得的報酬可能會是浮動的，表示每一個arm的報酬可能是某種distribution，每次使用的時候就會從distribution裡面隨機抽樣出來當作是這次使用的報酬，而Thompson sampling覺得這個distribution應該是beta distribution，一個beta distribution會由兩個變數a、b來決定，也就是每個arm自帶的參數，因此在某個時間點選擇要使用哪一個arm的時候，就是每一個arm都從beta distribution裡面抽樣一個數字出來，看誰的數字最大就選擇哪個arm。</p>

<h2 id="linucb">LinUCB</h2>

<p>LinUCB相較於UCB，多了使用者的資訊在裡面，其公式長得大概像這樣</p>

\[LinUCB_a=E(r_a \vert x)+\alpha STD(r_a \vert x)=x^T*\theta_a+\alpha\sqrt{x^TA_a^{-1}x}\]

<p>在上面的$x$表示的是使用者的特徵向量，而$\theta_a$和$A_a$是某一個arm本身自帶的參數，跟UCB一樣，左邊這項表示對過去這個使用者對這個arm的喜好程度，而右邊這項表示使用者願意exploration的分數。</p>

<h2 id="參考資料">參考資料</h2>

<ol>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/35753281">Contextual Bandit算法在推荐系统中的实现及应用</a></p>
  </li>
  <li>
    <p><a href="https://blog.tsingjyujing.com/ml/rl/mab-summary">Re：从零开始的Multi-armed Bandit</a></p>
  </li>
  <li>
    <p><a href="https://yangxudong.github.io/contextual-bandit/">在生产环境的推荐系统中部署Contextual bandit (LinUCB)算法的经验和陷阱</a></p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/381585388">MAB系列1：Contextual-free Bandits</a></p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/384427160">MAB系列2：Contextual Bandits: LinUCB</a></p>
  </li>
</ol>]]></content><author><name>Your Name</name></author><category term="Bandit" /><summary type="html"><![CDATA[最近剛好有機會碰了一下一直聽過但都沒有實際碰過的Bandit Algorithms，這邊紀錄一下從網路上學習到的知識。]]></summary></entry><entry><title type="html">nginx Reverse Proxy</title><link href="https://wjohn1483.github.io/2024/01/20/nginx-reverse-proxy/" rel="alternate" type="text/html" title="nginx Reverse Proxy" /><published>2024-01-20T00:00:00+00:00</published><updated>2024-01-20T00:00:00+00:00</updated><id>https://wjohn1483.github.io/2024/01/20/nginx-reverse-proxy</id><content type="html" xml:base="https://wjohn1483.github.io/2024/01/20/nginx-reverse-proxy/"><![CDATA[<p>最近想要把在同一台機器上面的不同服務都使用同一個port來去做serving，這邊記錄一下嘗試使用nginx來做reverse proxy的過程。</p>

<!--more-->

<p>在機器上因為不同的需求開了兩個不同的服務在不同的port，但想要讓這兩個服務都透過相同的port 80來給使用者來做使用，這時候我們可以使用nginx的反向代理功能來讓使用者使用相同的port 80，搭配不同的path來連到不同的服務。</p>

<h2 id="安裝nginx">安裝nginx</h2>

<p>底下是在CentOS上面安裝時使用的指令，不同的作業系統的安裝方法可以參考<a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/">官網</a>上的介紹。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> nginx
</code></pre></div></div>

<h2 id="設定nginx">設定nginx</h2>

<p>關於nginx的設定都放在<code class="language-plaintext highlighter-rouge">/etc/nginx/nginx.conf</code>裡面，我們可以在http$\rightarrow$server的區塊裡面，新增不同的path來讓nginx來做反向代理。</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For more information on configuration, see:</span>
<span class="c1">#   * Official English Documentation: http://nginx.org/en/docs/</span>
<span class="c1">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span>

<span class="k">user</span> <span class="s">nginx</span><span class="p">;</span>
<span class="k">worker_processes</span> <span class="s">auto</span><span class="p">;</span>
<span class="k">error_log</span> <span class="n">/var/log/nginx/error.log</span><span class="p">;</span>
<span class="k">pid</span> <span class="n">/run/nginx.pid</span><span class="p">;</span>

<span class="c1"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span>
<span class="k">include</span> <span class="n">/usr/share/nginx/modules/*.conf</span>;

<span class="k">events</span> <span class="p">{</span>
    <span class="kn">worker_connections</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
    <span class="kn">log_format</span>  <span class="s">main</span>  <span class="s">'</span><span class="nv">$remote_addr</span> <span class="s">-</span> <span class="nv">$remote_user</span> <span class="s">[</span><span class="nv">$time_local</span><span class="s">]</span> <span class="s">"</span><span class="nv">$request</span><span class="s">"</span> <span class="s">'</span>
                      <span class="s">'</span><span class="nv">$status</span> <span class="nv">$body_bytes_sent</span> <span class="s">"</span><span class="nv">$http_referer</span><span class="s">"</span> <span class="s">'</span>
                      <span class="s">'"</span><span class="nv">$http_user_agent</span><span class="s">"</span> <span class="s">"</span><span class="nv">$http_x_forwarded_for</span><span class="s">"'</span><span class="p">;</span>

    <span class="kn">access_log</span>  <span class="n">/var/log/nginx/access.log</span>  <span class="s">main</span><span class="p">;</span>

    <span class="kn">sendfile</span>            <span class="no">on</span><span class="p">;</span>
    <span class="kn">tcp_nopush</span>          <span class="no">on</span><span class="p">;</span>
    <span class="kn">tcp_nodelay</span>         <span class="no">on</span><span class="p">;</span>
    <span class="kn">keepalive_timeout</span>   <span class="mi">65</span><span class="p">;</span>
    <span class="kn">types_hash_max_size</span> <span class="mi">4096</span><span class="p">;</span>

    <span class="kn">gzip_static</span> <span class="no">off</span><span class="p">;</span>

    <span class="kn">include</span>             <span class="n">/etc/nginx/mime.types</span><span class="p">;</span>
    <span class="kn">default_type</span>        <span class="nc">application/octet-stream</span><span class="p">;</span>

    <span class="c1"># Load modular configuration files from the /etc/nginx/conf.d directory.</span>
    <span class="c1"># See http://nginx.org/en/docs/ngx_core_module.html#include</span>
    <span class="c1"># for more information.</span>
    <span class="kn">include</span> <span class="n">/etc/nginx/conf.d/*.conf</span><span class="p">;</span>

    <span class="kn">server</span> <span class="p">{</span>
        <span class="kn">listen</span>       <span class="mi">80</span><span class="p">;</span>
        <span class="kn">listen</span>       <span class="s">[::]:80</span><span class="p">;</span>
        <span class="kn">server_name</span>  <span class="s">&lt;YOUR_HOST_NAME&gt;</span><span class="p">;</span>

        <span class="c1"># Load configuration files for the default server block.</span>
        <span class="kn">include</span> <span class="n">/etc/nginx/default.d/*.conf</span><span class="p">;</span>

        <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
            <span class="kn">proxy_pass</span> <span class="s">http://localhost:8000</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kn">location</span> <span class="n">/test</span> <span class="p">{</span>
            <span class="kn">rewrite</span> <span class="s">^/test(/.*)</span>$ <span class="nv">$1</span> <span class="s">break</span><span class="p">;</span>
            <span class="kn">proxy_pass</span> <span class="s">http://localhost:9000</span><span class="p">;</span>
            <span class="kn">proxy_redirect</span> <span class="n">/</span> <span class="n">/test/</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kn">error_page</span> <span class="mi">404</span> <span class="n">/404.html</span><span class="p">;</span>
        <span class="kn">location</span> <span class="p">=</span> <span class="n">/404.html</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="kn">error_page</span> <span class="mi">500</span> <span class="mi">502</span> <span class="mi">503</span> <span class="mi">504</span> <span class="n">/50x.html</span><span class="p">;</span>
        <span class="kn">location</span> <span class="p">=</span> <span class="n">/50x.html</span> <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在上面的例子裡面，我們新增了底下的設定</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">location</span> <span class="n">/</span> <span class="p">{</span>
            <span class="kn">proxy_pass</span> <span class="s">http://localhost:8000</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">location</span> <span class="n">/test</span> <span class="p">{</span>
            <span class="kn">rewrite</span> <span class="s">^/test(/.*)</span>$ <span class="nv">$1</span> <span class="s">break</span><span class="p">;</span>
            <span class="kn">proxy_pass</span> <span class="s">http://localhost:9000</span><span class="p">;</span>
            <span class="kn">proxy_redirect</span> <span class="n">/</span> <span class="n">/test/</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>我們使用<code class="language-plaintext highlighter-rouge">proxy_pass</code>來將不同path的request傳到對應的服務上，假如使用者連到<code class="language-plaintext highlighter-rouge">HOST/</code>，就會導到<code class="language-plaintext highlighter-rouge">localhost:8000</code>，如果連到<code class="language-plaintext highlighter-rouge">HOST/test/</code>就會導到<code class="language-plaintext highlighter-rouge">localhost:9000</code>。</p>

<p>不過如果只有單純的<code class="language-plaintext highlighter-rouge">proxy_pass</code>，被重新導向的路徑會也帶上使用者加上的<code class="language-plaintext highlighter-rouge">/test/</code>，倘若希望在導向的時候將這個path給去除，讓服務收到的request是<code class="language-plaintext highlighter-rouge">/</code>的話，可以使用<code class="language-plaintext highlighter-rouge">rewrite</code>來對request做修改。</p>

<p>同樣地，如果服務收到<code class="language-plaintext highlighter-rouge">/</code>的request以後，想重新導向到服務的<code class="language-plaintext highlighter-rouge">/redirect</code>路徑，這時使用者實際上要request的就會需要是<code class="language-plaintext highlighter-rouge">HOST/test/redirect</code>，我們可以使用<code class="language-plaintext highlighter-rouge">proxy_redirect</code>來幫服務的重新導向加上<code class="language-plaintext highlighter-rouge">/test/</code>的前綴。</p>

<h2 id="啟動nginx">啟動nginx</h2>

<p>在寫好configuration以後，我們可以透過<code class="language-plaintext highlighter-rouge">nginx -t</code>來檢驗設定檔有沒有寫錯的地方，如果順利通過就能將nginx的服務起起來了。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> /usr/sbin/nginx <span class="nt">-t</span>
<span class="nb">sudo </span>service nginx start
<span class="nb">sudo </span>service nginx reload
chkconfig nginx on
</code></pre></div></div>

<p>而nginx本身的log會寫到底下的路徑，每當有使用者連線進來，就會寫到<code class="language-plaintext highlighter-rouge">access.log</code>，如果發生了錯誤會寫到<code class="language-plaintext highlighter-rouge">error.log</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/var/log/nginx/access.log
/var/log/nginx/error.log
</code></pre></div></div>

<p>如果之後設定檔有做其他的修改，只需要執行<code class="language-plaintext highlighter-rouge">nginx reload</code>就可以讓新的設定生效。</p>

<h2 id="參考資料">參考資料</h2>

<ol>
  <li><a href="https://blog.containerize.com/zh-hant/how-to-setup-and-configure-nginx-as-reverse-proxy/">如何設置和配置為反向代理</a></li>
</ol>]]></content><author><name>Your Name</name></author><category term="Tool" /><summary type="html"><![CDATA[最近想要把在同一台機器上面的不同服務都使用同一個port來去做serving，這邊記錄一下嘗試使用nginx來做reverse proxy的過程。]]></summary></entry></feed>